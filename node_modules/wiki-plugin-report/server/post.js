(function() {
  var Farm, Port, Site, Sufix, child, compose, enclose, fetchPage, findPaths, findPubs, findSchedule, flow, fold, fs, header, links, print, ready, report, sendmail,
    slice = [].slice;

  child = require('child_process');

  fs = require('fs');

  report = require('./report.js');

  print = function() {
    var arg;
    arg = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return console.log.apply(console, arg);
  };

  Site = process.env.Site || null;

  Port = process.env.Port || '';

  if (!Site) {
    Farm = process.env.Farm || '../../../data/farm';
  }

  Sufix = process.env.Sufix || 'report';

  findPaths = function(done) {
    if (Farm) {
      return child.exec("ls " + Farm + "/*/pages/*-" + Sufix, function(err, stdout, stderr) {
        var i, len, path, ref, ref1, results, site, slug, x;
        ref = stdout.split(/\n/);
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          path = ref[i];
          if (path === '') {
            continue;
          }
          ref1 = path.split('/').reverse(), slug = ref1[0], x = ref1[1], site = ref1[2];
          results.push(done(path, site, slug));
        }
        return results;
      });
    } else {
      return child.exec("ls ../../../data/pages/*-" + Sufix, function(err, stdout, stderr) {
        var i, len, path, ref, results, slug;
        ref = stdout.split(/\n/);
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          path = ref[i];
          if (path === '') {
            continue;
          }
          slug = path.split('/').reverse()[0];
          results.push(done(path, Site, slug));
        }
        return results;
      });
    }
  };

  fetchPage = function(path, done) {
    var text;
    return text = fs.readFile(path, 'utf8', function(err, text) {
      if (err) {
        return console.log(['fetchPage', path, err]);
      }
      return done(JSON.parse(text));
    });
  };

  findSchedule = function(page) {
    var i, item, len, ref;
    ref = page.story;
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      if (item.type === 'report') {
        return report.parse(item.text);
      }
    }
    return null;
  };

  findPubs = function(done) {
    return findPaths(function(path, site, slug) {
      return fetchPage(path, function(page) {
        var i, issue, len, ref, results, schedule;
        if (schedule = findSchedule(page)) {
          results = [];
          for (i = 0, len = schedule.length; i < len; i++) {
            issue = schedule[i];
            if ((issue.interval != null) && ((ref = issue.recipients) != null ? ref.length : void 0)) {
              results.push(done({
                site: site,
                slug: slug,
                page: page,
                schedule: schedule,
                issue: issue
              }));
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      });
    });
  };

  links = function(text) {
    return text.replace(/\[(http.*?) +(.*?)\]/gi, "[$2]");
  };

  flow = function(text) {
    return text.replace(/\s+/g, ' ') + "\n";
  };

  fold = function(text) {
    return text.match(/.{1,50}(\s|$)|\S+?(\s|$)/g).join("\n");
  };

  compose = function(page, since) {
    var action, active, i, item, j, len, len1, ref, ref1, result;
    active = {};
    ref = page.journal;
    for (i = 0, len = ref.length; i < len; i++) {
      action = ref[i];
      if (action.date && action.date > since) {
        if (action.type === 'add') {
          active[action.id] = 'NEW';
        }
        if (action.type === 'edit' && !active[action.id]) {
          active[action.id] = 'UPDATE';
        }
      }
    }
    result = [];
    ref1 = page.story;
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      item = ref1[j];
      if (item.type === 'paragraph' && active[item.id]) {
        result.push(active[item.id]);
        result.push(fold(flow(links(item.text))));
      }
    }
    return result.join("\n");
  };

  ready = function(arg1) {
    var issue, lapse, now, period, thisIssue, window;
    issue = arg1.issue, now = arg1.now, period = arg1.period;
    window = period * 60 * 1000;
    thisIssue = report.advance(now, issue, 0);
    lapse = now.getTime() - thisIssue.getTime();
    return lapse < window;
  };

  header = function(fields) {
    var k, v;
    return ((function() {
      var results;
      results = [];
      for (k in fields) {
        v = fields[k];
        results.push(k + ": " + v);
      }
      return results;
    })()).join("\n");
  };

  enclose = function(arg1) {
    var issue, page, site, slug, summary;
    site = arg1.site, slug = arg1.slug, page = arg1.page, issue = arg1.issue, summary = arg1.summary;
    return [
      header({
        To: issue.recipients.join(", "),
        'Reply-to': issue.recipients.join(", "),
        Subject: page.title + " (" + issue.interval + ")"
      }), page.title + "\nPublished " + issue.interval + " from Federated Wiki", summary, "See details at\nhttp://" + site + Port + "/" + slug + ".html"
    ].join("\n\n");
  };

  sendmail = function(pub) {
    var output, send;
    output = [];
    send = child.spawn('/usr/sbin/sendmail', ['-fward@wiki.org', '-t']);
    send.stdin.write(pub.message);
    send.stdin.end();
    send.stderr.setEncoding('utf8');
    send.stderr.on('data', function(data) {
      return output.push(data);
    });
    return send.on('exit', function(code) {
      print("sent " + pub.page.title + " (" + pub.issue.interval + "), code: " + code);
      return print(output.join(''));
    });
  };

  findPubs(function(pub) {
    pub.now = new Date(2012, 12 - 1, 21, 0, 0, 3);
    pub.now = new Date();
    pub.period = 60;
    if (ready(pub)) {
      pub.summary = compose(pub.page, report.advance(pub.now, pub.issue, -1));
      if (pub.summary !== '') {
        pub.message = enclose(pub);
        return sendmail(pub);
      }
    }
  });

}).call(this);

//# sourceMappingURL=post.js.map
