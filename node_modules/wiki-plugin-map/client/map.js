
/*
 * Federated Wiki : Map Plugin
 *
 * Licensed under the MIT license.
 * https://github.com/fedwiki/wiki-plugin-map/blob/master/LICENSE.txt
 */

(function() {
  var bind, emit, escape, feature, htmlDecode, lineup, marker, parse, resolve;

  escape = function(line) {
    return line.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  };

  resolve = function(text) {
    if (typeof wiki !== "undefined" && wiki !== null) {
      return wiki.resolveLinks(text, escape);
    } else {
      return escape(text).replace(/\[\[.*?\]\]/g, '<internal>').replace(/\[.*?\]/g, '<external>');
    }
  };

  htmlDecode = function(escapedText) {
    var doc;
    doc = new DOMParser().parseFromString(escapedText, "text/html");
    return doc.documentElement.textContent;
  };

  marker = function(text) {
    var decimal, deg, m, nautical;
    deg = function(m) {
      var num;
      num = +m[0] + m[1] / 60 + (m[2] || 0) / 60 / 60;
      if (m[3].match(/[SW]/i)) {
        return -num;
      } else {
        return num;
      }
    };
    decimal = /^(-?\d{1,3}\.?\d*)[, ] *(-?\d{1,3}\.?\d*)\s*(.*)$/;
    nautical = /^(\d{1,3})°(\d{1,2})'(\d*\.\d*)?"?([NS]) (\d{1,3})°(\d{1,2})'(\d*\.\d*)?"?([EW]) (.*)$/i;
    if (m = decimal.exec(text)) {
      return {
        lat: +m[1],
        lon: +m[2],
        label: resolve(m[3])
      };
    }
    if (m = nautical.exec(text)) {
      return {
        lat: deg(m.slice(1, 5)),
        lon: deg(m.slice(5, 9)),
        label: resolve(m[9])
      };
    }
    return null;
  };

  lineup = function($item) {
    var candidates, div, i, len, markers, who;
    if (typeof wiki === "undefined" || wiki === null) {
      return [
        {
          lat: 51.5,
          lon: 0.0,
          label: 'North Greenwich'
        }
      ];
    }
    markers = [];
    candidates = $(".item:lt(" + ($('.item').index($item)) + ")");
    if ((who = candidates.filter(".marker-source")).size()) {
      for (i = 0, len = who.length; i < len; i++) {
        div = who[i];
        markers = markers.concat(div.markerData());
      }
    }
    return markers;
  };

  parse = function(text, $item) {
    var boundary, captions, hint, hints, i, len, line, m, markers, ref, result, weblink;
    captions = [];
    markers = [];
    boundary = null;
    weblink = null;
    ref = text.split(/\n/);
    for (i = 0, len = ref.length; i < len; i++) {
      line = ref[i];
      if (m = marker(line)) {
        if (weblink != null) {
          m.weblink = weblink;
        }
        markers.push(m);
      } else if (m = /^BOUNDARY *(.*)?$/.exec(line)) {
        hints = (hint = marker(m[1])) ? [hint] : [];
        if (boundary == null) {
          boundary = markers.concat([]);
        }
        boundary = boundary.concat(hints);
      } else if (/^LINEUP/.test(line)) {
        markers = markers.concat(lineup($item));
      } else if (m = /^WEBLINK *(.*)$/.exec(line)) {
        weblink = m[1];
      } else {
        captions.push(resolve(line));
      }
    }
    if (boundary == null) {
      boundary = markers;
    }
    result = {
      markers: markers,
      caption: captions.join('<br>'),
      boundary: boundary
    };
    if (weblink != null) {
      result.weblink = weblink;
    }
    return result;
  };

  feature = function(marker) {
    return {
      type: 'Feature',
      geometry: {
        type: 'Point',
        coordinates: [marker.lon, marker.lat],
        properties: {
          label: marker.label
        }
      }
    };
  };

  emit = function($item, item) {
    var boundary, caption, markers, ref, showing, weblink;
    ref = parse(item.text, $item), caption = ref.caption, markers = ref.markers, boundary = ref.boundary, weblink = ref.weblink;
    $item.addClass('marker-source');
    showing = [];
    $item.get(0).markerData = function() {
      var opened;
      opened = showing.filter(function(s) {
        return s.leaflet._popup._isOpen;
      });
      if (opened.length) {
        return opened.map(function(s) {
          return s.marker;
        });
      } else {
        return parse(item.text).markers;
      }
    };
    $item.get(0).markerGeo = function() {
      return {
        type: 'FeatureCollection',
        features: parse(item.text).markers.map(feature)
      };
    };
    if (!$("link[href='http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.css']").length) {
      $('<link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.css">').appendTo("head");
    }
    if (!$("link[href='/plugins/map/map.css']").length) {
      $('<link rel="stylesheet" href="/plugins/map/map.css" type="text/css">').appendTo("head");
    }
    return wiki.getScript("http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.js", function() {
      var bounds, map, mapId, openWeblink, p, showMarkers, tile, tileCredits, update;
      mapId = "map-" + (Math.floor(Math.random() * 1000000));
      $item.append("<figure style=\"padding: 8px;\">\n  <div id=\"" + mapId + "\" style='height: 300px;'></div>\n  <p class=\"caption\">" + caption + "</p>\n</figure>");
      map = L.map(mapId);
      update = function() {
        return wiki.pageHandler.put($item.parents('.page:first'), {
          type: 'edit',
          id: item.id,
          item: item
        });
      };
      map.doubleClickZoom.disable();
      map.on('dblclick', function(e) {
        if (e.originalEvent.shiftKey) {
          e.originalEvent.stopPropagation();
          new L.marker(e.latlng).addTo(map);
          item.text += "\n" + (e.latlng.lat.toFixed(7)) + ", " + (e.latlng.lng.toFixed(7));
          return update();
        }
      });
      tile = item.tile || "http://{s}.tile.osm.org/{z}/{x}/{y}.png";
      tileCredits = item.tileCredits || '<a href="http://osm.org/copyright">OSM</a>';
      L.tileLayer(tile, {
        attribution: tileCredits
      }).addTo(map);
      openWeblink = function(e) {
        var link;
        if (!(link = e.target.options.weblink)) {
          return;
        }
        return window.open(link.replace(/\{LAT}/, e.latlng.lat).replace(/\{(LON|LNG)}/, e.latlng.lng));
      };
      showMarkers = function(markers) {
        var i, len, markerLabel, mkr, p, results;
        if (!markers) {
          return;
        }
        results = [];
        for (i = 0, len = markers.length; i < len; i++) {
          p = markers[i];
          markerLabel = htmlDecode(wiki.resolveLinks(p.label));
          mkr = L.marker([p.lat, p.lon], {
            weblink: p.weblink || weblink
          }).on('dblclick', openWeblink).bindPopup(markerLabel).openPopup().addTo(map);
          results.push(showing.push({
            leaflet: mkr,
            marker: p
          }));
        }
        return results;
      };
      showMarkers(markers);
      if (boundary.length > 1) {
        bounds = new L.LatLngBounds([
          (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = boundary.length; i < len; i++) {
              p = boundary[i];
              results.push([p.lat, p.lon]);
            }
            return results;
          })()
        ]);
        return map.fitBounds(bounds);
      } else if (boundary.length === 1) {
        p = boundary[0];
        return map.setView([p.lat, p.lon], item.zoom || 13);
      } else {
        return map.setView(item.latlng || item.latLng || [40.735383, -73.984655], item.zoom || 13);
      }
    });
  };

  bind = function($item, item) {
    return $item.dblclick(function() {
      return wiki.textEditor($item, item);
    });
  };

  if (typeof window !== "undefined" && window !== null) {
    window.plugins.map = {
      emit: emit,
      bind: bind
    };
  }

  if (typeof module !== "undefined" && module !== null) {
    module.exports = {
      marker: marker,
      parse: parse
    };
  }

}).call(this);

//# sourceMappingURL=map.js.map
